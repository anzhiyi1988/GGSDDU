# 状态管理

所谓状态管理，就是在整个在计算过程中，需要记录一些数据的状态

比如，求某个key的最大值，随着流的不停进入，同一个key的最大值可能会发生变换，所以这是就要记录一下当下的最大值，当这个key再次进入后，先判断新值和内存中的值哪个大？然后保留的最大的。



# 事件的时间

也就是每条数据的时间戳，有三种

一种是数据**本身**就有的时间戳

一种是Flink程序**接到**数据时，给数据标签一个时间戳

一个是Flink程序**处理**数据时，给数据标签一个时间戳



时间干什么用的，就是为了 窗口处理 和 水印处理



# 水印

比如 要按顺序输出一个正在处理的流，这个流还是无序到达的。

··· 23 19 22 24 21 14 17 13 12 15 9 11 7 2 4 →

应该先输出2，但是4先到的，咋整？ 先缓存一下呗，不着急输出，让输出延迟一会。那么延迟多长时间呢？这就需要一个策略。

针对上面的排序，我们策略是，下一个到达的数字 大于等于 上一个数字，则输出上一个数字

那么水印怎么用呢，当到达一个数字后，把水印设置为这个数字，然后等待，又来一个数字，这个数字和水印比较，大于等于了，则输出上一个数字，把水印置为新的这个数字，依次类推。



| 达到的数字 | 内存中的数字 | 输出的数字 | 水印 |
| ---- | ---- | ---- | ---- |
| 4 | 4 |  | 4 |
| 2    | 2 4 |  | 4    |
| 7 | 7 | 4 2 | 7 |
| 11 | 11 | 7 | 11 |
| 9 | 9 11 |      | 11 |
| 15 | 15 | 11 9 | 15 |

这里有个问题，就是在到14的时候，15已经输出了，似乎是不对的，这说明我们的策略有问题，但是，我们不能一直等，那样的话延迟太大了。

显示程序中需要平衡这个事情，比如实时计算可能会有错误，每天结束时清算一下。



# 窗口

 

