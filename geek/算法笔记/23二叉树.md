## 树tree

A 节点就是 B 节点的父节点，B 节点是 A 节点的子节点。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫作根节点，也就是图中的节点 E。我们把没有子节点的节点叫作叶子节点或者叶节点，比如图中的 G、H、I、J、K、L 都是叶子节点。

![img](../../image/220043e683ea33b9912425ef759556ae.jpg)

高度（Height）、深度（Depth）、层（Level）

![img](../../image/4094a733986073fedb6b9d03f877d71e.jpg)

![img](../../image/50f89510ad1f7570791dd12f4e9adeb4.jpg)



## 二叉树 binary tree

每个节点最多有两个“叉”

![img](../../image/09c2972d56eb0cf67e727deda0e9412b.jpg)

编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作**满二叉树**。

编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作**完全二叉树**。

## 存储方式

链式存储法

![img](../../image/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg)

顺序存储法

![img](../../image/14eaa820cb89a17a7303e8847a412330.jpg)



如果一棵树不是完全二叉树，则用顺序存储法很浪费空间，如下

![img](../../image/08bd43991561ceeb76679fbb77071223.jpg)

所以，如果是完全二叉树，采用顺序存储法就很省空间。

## 二叉树遍历

前序遍历、中序遍历和后序遍历。

前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。

中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。

后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身

![img](../../image/ab103822e75b5b15c615b68560cb2416.jpg)



## 二叉查找树 binary search tree

又叫二叉搜索树，是为了快速查找而生的，而且还支持快速插入、删除。

结构定义：树中，任意一个节点，其左子树中的每个节点的值都要小于这个节点，而右子树中的每个节点的值都大于这个节点，如下图：

![img](../../image/f3bb11b6d4a18f95aa19e11f22b99bae.jpg)



## 散列表和二叉搜索树比较

散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？

第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。

第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。

第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。

第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。

最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。

综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。