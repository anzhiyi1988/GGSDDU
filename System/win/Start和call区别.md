call的时候，他们拥有同一个壳cmd.exe，在同一个进程当中，所以他们的变量是互通的。

start的时候，他们拥有两个壳cmd.exe，但child.bat可以看成是main.bat的子进程，子进程可以读取父进程中的变量（即a的值）。

**总结结论：**

对于start，概况二句话：“不同进程不能传值”，“相同进程单向传值，老子传儿子，非儿子传老子”。

对于call，“同一进程，变量互通”。

另外，可以从以下几方面理解start与call命令的区别：

一是调用范围不同：call主要用来进行批处理的内部调用，如call :pend 和一些dos命令的调用如call set test=2，但也可以调用其他可执行文件，而start则不能进行内部调用，但其可以执行基本上所有的外部程序，还可以执行shell，如打开文件夹start "" "%WINDIR%"，安装网络打印机start "" "[\\IP\Printer](file://IP/Printer)"等等。

二是调用方式不同：call是严格意义上而言的调用，在call另一个批处理时是在同一窗体进程里执行，而start则是执行，所以在执行另外一个批处理时是在不同的窗体进程里进行，也就是说在新开启的进程里执行，虽然start可以加入b参数，但其结果却完全不同。如我们使用call set test=2 和 start /b set test=2 看似执行的结果相同，但是我们发现后者有两个进程，而且在窗体里要执行两次exit才能退出，所以当我们使用start来执行一个批处理后最好在被调用的批处理中也加一个exit，否则无法退出被调用的批处理的dos窗体，但是使用call调用时如果在被调用的批处理中存在exit则会直接结束原始和被调用的批处理程序，这是一个非常严重的问题。建议在被调用的批处理中使用goto :eof来取代exit。

三是调用结果不同：call调用不仅可以把参数或变量传给被调用的批处理，而且被调用的批处理也可以设置参数或变量以便回传，而start只能把参数或变量传给被调用的批处理，却不能回传参数或变量，这一点实际上是第二点的延伸。另外，我们还必须注意一点：使用call调用其他批处理时，在被调用的批处理中若我们使用goto命令的时候，建议要使用与原批处理中不同的标签名来跳转，否则可能会跳转到原批处理中而不能保证完整的执行被调用批处理中的所有语句。

 

来自 <<http://www.cnblogs.com/Braveliu/p/5078283.html>> 