# Spring常见的依赖注入的方式

构造器注入：通过构造方法的参数注入依赖

setter注入：调用setter方法注入依赖

字段注入：在类属性上使用@autowired或者@Resource注入

# 各种注入方式的优缺点

构造器注入： 强依赖、不可变，因为用了构造方法，说明此类必须使用这些依赖。

setter注入：可选、可变，类中对这些依赖不是强依赖，可以注入也可不注入。

字段注入：尽量不要使用这种方式，一定要用的话@Resource比@autowired对IOC容器的耦合更低。

## Field注入的缺点

- **不能像构造器那样注入不可变的对象**
- **依赖对外部不可见**，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖
- 会导致**组件与IoC容器紧耦合**（这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难），导致**单元测试也必须使用IoC容器**
- **依赖过多时不够明显**，比如我需要10个依赖，用构造器注入就会显得庞大，这时候应该考虑一下此组件是不是**违反了单一职责原则**

# autowired VS resource

**依赖识别方式**：autowired是通过byType注入，可以使用@qualifier指定name；resource是通过byname注入，如果找不到则bytype。

**适用对象**：autowired对构造器、方法、参数、字段使用，resource只能对方法、字段使用。

**提供方**：autowired是spring定义的，resource是JSR-250定义的。

# 总结

Field注入虽然有很多缺点，但它的好处也不可忽略：那就是**太方便了**。使用构造器或者setter注入需要写更多业务无关的代码，十分麻烦，而字段注入大幅简化了它们。并且绝大多数情况下业务代码和框架就是强绑定的，完全松耦合只是一件理想上的事，牺牲了敏捷度去过度追求松耦合反而得不偿失。

那么问题来了，为什么IDEA只对@Autowired警告，却对@Resource视而不见呢？

**个人认为**，就像我们前面提到过的：**@Autowired**是**Spring**提供的，它是**特定IoC提供的特定注解**，这就导致了应用与框架的**强绑定**，一旦换用了其他的IoC框架，是**不能够支持注入**的。而**@Resource**是**JSR-250**提供的，它是**Java标准**，我们使用的IoC容器应当去兼容它，这样即使更换容器，也可以正常工作。

# 参考网站

https://blog.csdn.net/k_young1997/article/details/112268535